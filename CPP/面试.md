### 僵尸进程（Zombie Process）

僵尸进程（Zombie Process），又称为僵尸子进程，是一种已经终止但其进程控制块（Process Control Block，PCB）仍然存在于进程表中的进程。僵尸进程的存在主要是为了让父进程读取子进程的退出状态。

**僵尸进程的产生**

僵尸进程的产生过程如下：

1. 子进程终止时，会向父进程发送一个`SIGCHLD`信号，通知父进程它已结束。
2. 子进程的退出状态信息（包括退出码等）会存储在内核的进程表中，等待父进程来获取。
3. 父进程调用`wait`或`waitpid`函数来获取子进程的退出状态信息，并释放其占用的资源。
4. 如果父进程没有调用`wait`或`waitpid`，子进程的退出状态信息将一直保留在进程表中，此时这个子进程就成为僵尸进程。

**僵尸进程的危害**

僵尸进程本身不会占用CPU时间和内存，因为它已经结束，只保留了一些必要的信息。但是，如果父进程没有及时回收僵尸进程，而系统中又产生了大量的僵尸进程，会导致进程表（一个固定长度的结构）被填满，进而阻止新的进程创建，影响系统的正常运行。

**如何处理僵尸进程**

处理僵尸进程的方法主要有以下几种：

**1. 父进程调用`wait`或`waitpid`**

父进程可以在适当的时候调用`wait`或`waitpid`来回收已结束的子进程。

```c++
#include <sys/wait.h>
#include <unistd.h>
#include <stdio.h>

int main() {
    pid_t pid = fork();
    if (pid == 0) {
        // 子进程
        printf("Child process\n");
        _exit(0); // 立即退出
    } else {
        // 父进程
        int status;
        waitpid(pid, &status, 0); // 等待子进程结束并获取其退出状态
        printf("Child process has ended\n");
    }
    return 0;
}

```

**2. 捕捉`SIGCHLD`信号**

父进程可以设置一个`SIGCHLD`信号处理函数，当子进程结束时自动回收它。

```C++
#include <sys/wait.h>
#include <unistd.h>
#include <signal.h>
#include <stdio.h>

void handle_sigchld(int sig) {
    // 回收所有结束的子进程
    while (waitpid(-1, NULL, WNOHANG) > 0);
}

int main() {
    struct sigaction sa;
    sa.sa_handler = handle_sigchld;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    sigaction(SIGCHLD, &sa, NULL);

    pid_t pid = fork();
    if (pid == 0) {
        // 子进程
        printf("Child process\n");
        _exit(0); // 立即退出
    } else {
        // 父进程
        sleep(10); // 模拟父进程的工作
        printf("Parent process has ended\n");
    }
    return 0;
}

```

**3. 将子进程重新分配给init进程**

当父进程不再需要子进程时，可以通过`fork`创建子进程，然后父进程立即退出，这样子进程会被init进程接管（因为init进程是所有孤儿进程的父进程），init进程会自动回收子进程。

```c++
#include <unistd.h>
#include <stdio.h>

int main() {
    pid_t pid = fork();
    if (pid == 0) {
        // 子进程
        printf("Child process\n");
        sleep(5); // 模拟子进程的工作
        printf("Child process has ended\n");
        _exit(0);
    } else {
        // 父进程
        printf("Parent process\n");
        _exit(0); // 父进程立即退出
    }
    return 0;
}

```

### 孤儿进程（Orphan Process）

孤儿进程（Orphan Process）是指其父进程已经终止，但它本身仍在运行的进程。当父进程终止后，孤儿进程会被操作系统重新分配给init进程（在现代Linux系统中为systemd进程），并由init进程接管。这是因为init进程是所有用户进程的最终父进程，它负责清理资源并回收已终止子进程的进程控制块（PCB）。

**孤儿进程的产生**

孤儿进程的产生过程如下：

1. 父进程创建一个或多个子进程。
2. 父进程终止，而子进程仍在运行。
3. 操作系统会自动将孤儿进程的父进程重新设置为init进程（PID 1）。
4. init进程会接管这些孤儿进程，并在它们终止时回收其资源。

**孤儿进程的处理**

孤儿进程由init进程接管，因此一般情况下不需要手动处理。init进程会负责回收所有孤儿进程，确保系统资源不会泄漏。

### 守护进程（Daemon Process）

守护进程（Daemon Process）是在计算机操作系统中以服务方式运行的一种特殊类型的进程。它通常在后台运行，独立于用户会话，并且没有控制终端。守护进程经常用于执行系统任务、服务或后台任务，如网络服务、定时任务等。

以下是关于守护进程的一些特点和常见用途：

1. **后台运行：** 守护进程在后台运行，不会占用用户的控制终端，也不会受到用户登录或注销的影响。
2. **独立于用户会话：** 守护进程通常以超级用户（root）身份运行，不受普通用户的限制，可以执行系统级别的任务。
3. **没有控制终端：** 守护进程不会与任何控制终端连接，因此无法通过标准输入、输出和错误流进行交互。
4. **服务性质：** 守护进程通常用于提供系统级别的服务，如网络服务（如HTTP服务器、FTP服务器）、定时任务（如定时备份）、监控服务（如系统监控）等。
5. **周期性运行：** 守护进程通常会周期性地执行特定的任务，或者持续监听某些事件，并根据需要作出相应的响应。
6. **可靠性：** 守护进程需要具备较高的稳定性和可靠性，因为它们通常是系统的核心组件之一，必须能够长时间稳定运行。

在 Unix/Linux 系统中，守护进程的特征通常包括以下几点：

- 通常以 `daemon` 后缀命名，例如 `httpd`、`sshd` 等。
- 在启动时会调用 `fork()` 函数来创建子进程，并使父进程退出，子进程继续作为守护进程运行。
- 会调用 `setsid()` 函数创建新的会话（Session），使进程摆脱控制终端的影响。
- 通常会将标准输入、输出、错误流重定向到 `/dev/null`，以防止输出信息干扰。
- 可能会使用配置文件进行参数设置，以便管理和调整守护进程的行为。

### override和overload

`override` 和 `overload` 是面向对象编程中常见的两个概念，它们分别表示重写（Override）和重载（Overload）的含义。

1. Override（重写）：
   - 在继承关系中，当子类重新实现（覆盖）父类的虚函数时，就称为重写（Override）。
   - 重写的函数在子类中有相同的名称、参数列表和返回类型，并且在父类中被声明为虚函数（或纯虚函数）。
   - 重写的目的是为了实现多态性（Polymorphism），即通过父类指针或引用调用子类的方法时，能够根据对象的实际类型调用对应的方法。
   - C++11 引入了 `override` 关键字，用于显式地标记一个函数是重写父类中的虚函数。如果使用 `override` 关键字声明的函数与基类中的虚函数不匹配，则会产生编译错误。

```c++
class Base {
public:
    virtual void display() const {
        std::cout << "Base display()" << std::endl;
    }
};

class Derived : public Base {
public:
    void display() const override { // 使用 override 显式声明重写
        std::cout << "Derived display()" << std::endl;
    }
};

```

**Overload（重载）：**

- 重载（Overload）指的是在同一个作用域内，允许定义多个具有相同名称但参数列表不同的函数。
- 重载函数可以具有不同的参数类型、参数个数或参数顺序。
- 重载的目的是为了提高函数的灵活性和适用性，允许使用相同的函数名来执行不同的操作。
- 在调用重载函数时，编译器会根据参数列表的类型和数量来选择合适的函数进行调用。

```c++
class Calculator {
public:
    int add(int a, int b) {
        return a + b;
    }

    double add(double a, double b) {
        return a + b;
    }
};

```

### 左值和右值的区别

左值（Lvalue）和右值（Rvalue）是 C++ 中与变量和表达式相关的概念，它们在赋值、传递参数和表达式求值等方面有重要的区别。

1. **左值（Lvalue）：**
   - 左值是指在表达式中具有地址的表达式，通常可以出现在赋值语句的左边。
   - 具有地址意味着左值可以被取地址（&）、被赋值（=）和被修改。
   - 通常情况下，变量、数组元素、对象成员、表达式结果等都是左值。
   - 例如：`int x = 10;` 中的 `x` 就是一个左值，因为它表示一个具有地址的变量。
2. **右值（Rvalue）：**
   - 右值是指在表达式中不具有地址的临时值，通常不能出现在赋值语句的左边。
   - 通常情况下，字面常量、临时对象、函数返回值等都是右值。
   - 右值可以被赋值（=）和用于计算表达式结果，但不能取地址（&）或被修改。
   - 例如：`int y = 5 + 3;` 中的 `5 + 3` 是一个右值，因为它是一个临时计算出的值。

### new 和 malloc

1、new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。

2、使⽤new操作符申请内存分配时⽆须指定内存块的⼤⼩，⽽malloc则需要显式地指出所需内存的尺⼨。 

3、opeartor new /operator delete可以被重载，而malloc/free并不允许重载。 

4、new/delete会调⽤对象的构造函数/析构函数以完成对象的构造/析构。⽽malloc则不会 

5、malloc与free是C++/C语⾔的标准库函数,new/delete是C++的运算符  

### 堆栈区别

在编程中，“堆”和“栈”是两种常见的数据结构，它们在内存管理和数据存储方面有很大的区别。

1. **内存分配：**
   - **栈：** 栈是一种先进后出（LIFO）的数据结构，用于存储函数的局部变量和函数调用的上下文信息。当函数被调用时，其局部变量会被分配到栈上，并在函数执行完毕后自动释放。因此，栈上的内存分配和释放是由程序自动管理的，通常效率较高。
   - **堆：** 堆是一种动态分配的内存区域，用于存储程序运行时动态分配的数据。堆上的内存分配和释放需要程序员手动管理，使用诸如`malloc`、`free`（在C/C++中）或`new`、`delete`（在C++中）等函数进行操作。堆的分配和释放可能会比较耗时，并且需要注意内存泄漏和内存碎片等问题。

2. **访问速度：**
   - **栈：** 由于栈上的内存分配和释放是由系统自动管理的，因此栈上的数据访问速度较快。栈上的数据存储方式是连续的，因此对于局部变量的访问非常高效。
   - **堆：** 堆上的内存分配和释放由程序员手动控制，因此访问速度可能相对较慢。此外，由于堆上的内存分配是动态的，数据的存储方式可能不是连续的，可能会导致访问效率下降。

3. **生存期：**
   - **栈：** 栈上的数据生命周期与其所在函数的执行周期相关联。当函数执行完毕时，其局部变量会被自动释放，因此栈上的数据生存期较短。
   - **堆：** 堆上的数据生命周期可以由程序员控制，可以在需要时手动分配内存，并在不再需要时手动释放。因此，堆上的数据生存期可以比较长，可以跨越函数调用或程序执行周期。

4. **内存大小**：

    - **栈：**内存的大小通常较小，受限于操作系统的栈大小设置，默认值可能在几百KB到几MB不等。

    -  **堆：**内存的大小仅受限于系统可用内存，因此可以分配较大的内存块。

### 局部变量和全局变量的区别

局部变量和全局变量是编程中变量作用域的两个基本概念，它们主要区别在于定义位置、作用范围和生命周期。以下是它们的具体区别：

**局部变量**

1. **定义位置**：
   - 局部变量是在函数或代码块内部定义的。
2. **作用范围**：
   - 局部变量的作用范围仅限于定义它的函数或代码块内部。在这个范围之外，局部变量是不可访问的。
3. **生命周期**：
   - 局部变量的生命周期是从进入其定义的作用域开始，到退出该作用域结束。每次进入该作用域时，局部变量都会重新创建并初始化。
4. **存储类型**：
   - 局部变量通常存储在栈内存中。
5. **命名冲突**：
   - 局部变量可以与全局变量同名。在这种情况下，局部变量会遮蔽（覆盖）全局变量，函数或代码块内使用的同名变量指的是局部变量。

**全局变量**

1. **定义位置**：
   - 全局变量是在所有函数之外定义的，通常在文件的顶部。
2. **作用范围**：
   - 全局变量的作用范围是整个程序，所有函数都可以访问全局变量，除非被局部变量遮蔽。
3. **生命周期**：
   - 全局变量的生命周期从程序开始运行到程序结束。它们在程序的整个执行过程中都存在。
4. **存储类型**：
   - 全局变量通常存储在静态内存区（全局/静态区）。
5. **命名冲突**：
   - 如果局部变量与全局变量同名，在局部变量的作用范围内，局部变量会遮蔽全局变量。同名全局变量在该作用范围外依然有效。

**局部变量**：在函数或代码块内定义，作用范围限于定义它的函数或代码块内，生命周期随作用域的进入和退出而开始和结束，存储在栈内存中。

**全局变量**：在所有函数之外定义，作用范围为整个程序，生命周期从程序开始到结束，存储在静态内存区。

### 静态内存区

静态内存区（也称为静态存储区或全局存储区）是程序运行期间用于存储全局变量、静态变量和常量数据的内存区域。与栈内存和堆内存不同，静态内存区有其独特的分配和生命周期特性。

**静态内存区的特点**

1. **分配和管理**：
   - 静态内存区的内存分配在程序启动时由操作系统完成，释放在程序结束时由操作系统处理。程序员不需要手动管理这部分内存。
   
2. **生命周期**：
   - 静态内存区中的变量在程序的整个生命周期内都存在。它们在程序开始执行时被初始化，并在程序结束时销毁。
   
3. **作用范围**：
   - 静态变量的作用范围取决于它们的定义位置。如果静态变量在函数内定义，它们的作用范围仅限于该函数，但其值在函数调用间保持不变。如果在函数外定义（全局变量），它们在整个程序中都可访问。
   
4. **初始值**：
   - 如果没有显式初始化，静态变量会被默认初始化为零（或等价于零值）。
   
5. **存储类型**：
   - 静态内存区通常存储在程序的.data段（用于初始化的静态变量）和.bss段（用于未初始化的静态变量）中。
   
### 静态链接和动态链接的区别

静态链接和动态链接是指在编译和链接过程中如何处理程序依赖的库的两种方式。它们在程序运行时加载和执行依赖库的方式上有所不同。以下是静态链接和动态链接的区别：

**静态链接（Static Linking）**

1. **链接时机**：
   - 静态链接在编译链接过程中完成，将程序所依赖的库文件（如静态库，通常以`.lib`、`.a`为扩展名）的代码和数据复制到最终生成的可执行文件中。
2. **文件大小**：
   - 生成的可执行文件较大，因为它包含了程序所依赖的所有库的代码和数据。
3. **加载**：
   - 在程序运行之前，所有的库都已经被链接到可执行文件中，因此程序运行时不需要额外加载依赖的库。
4. **依赖性**：
   - 可执行文件对所依赖的库的依赖性较高，因为所有库的代码都被打包到可执行文件中。如果需要更新或替换库，需要重新编译链接程序。
5. **移植性**：
   - 可执行文件在不同的平台上运行需要重新编译链接，因为依赖的库可能不同。

**动态链接（Dynamic Linking）**

1. **链接时机**：
   - 动态链接在程序运行时完成，程序所依赖的库的代码和数据并不在可执行文件中，而是保存在单独的共享库文件（如动态链接库，通常以`.dll`、`.so`为扩展名）中。
2. **文件大小**：
   - 生成的可执行文件较小，因为它只包含程序本身的代码和数据，而不包含依赖的库的代码和数据。
3. **加载**：
   - 在程序运行时，操作系统会在需要的时候加载所依赖的共享库，并将它们与程序链接起来。这样可以节省内存空间，并允许多个程序共享同一个共享库的实例。
4. **依赖性**：
   - 可执行文件对所依赖的库的依赖性较低，因为依赖的库是在运行时加载的，可以通过更新或替换共享库来更新程序的功能。
5. **移植性**：
   - 可执行文件在不同的平台上运行时，只需在相应平台上存在对应的共享库即可，无需重新编译链接程序。

**选择和注意事项**

- 静态链接的优点：

  - 可以生成独立的、可移植的可执行文件。
  - 减少了运行时加载依赖库的时间。

- 动态链接的优点：

  - 节省了磁盘空间和内存空间，避免了重复加载相同的库。
  - 可以在运行时更新和替换共享库，提高了程序的灵活性和可维护性。

在选择静态链接和动态链接时，需要考虑程序的需求、平台的兼容性以及可维护性等因素。通常，对于需要独立性和可移植性的应用程序，静态链接较为适合；而对于需要节省资源和支持动态更新的应用程序，动态链接则更加合适。

### 编译是从低地址还是高地址开始，编译过程如何找到main函数

在解释编译过程和程序执行时，通常会涉及到几个关键步骤：源代码的编译、链接过程以及程序的加载与执行。下面详细说明这些过程，并回答如何找到 `main` 函数。

**编译过程**

1. **预处理（Preprocessing）**：预处理器处理源代码中的指令（如 `#include`、`#define` 等），生成扩展的源代码。
2. **编译（Compilation）**：编译器将扩展的源代码转换成汇编代码。
3. **汇编（Assembly）**：汇编器将汇编代码转换成机器码，生成目标文件（通常是 `.o` 或 `.obj` 文件）。
4. **链接（Linking）**：链接器将一个或多个目标文件和库文件链接在一起，生成可执行文件。

**加载与执行**

1. **加载（Loading）**：加载器将可执行文件加载到内存中，并进行必要的地址重定位。
2. **执行（Execution）**：控制权转交给操作系统，启动程序执行。

**地址空间和入口点**

在程序执行时，操作系统会将可执行文件加载到内存中。加载的地址布局通常分为几个部分（代码段、数据段、堆、栈等），具体布局会因操作系统和编译器而异。

**找到 `main` 函数**

在 C/C++ 程序中，编译器默认生成的入口点并不是直接 `main` 函数，而是一个启动代码（通常称为 `_start` 或类似名称），它负责一些初始化工作，如设置堆栈、调用全局构造函数等。具体过程如下：

1. **入口点 `_start`**：链接器会将入口点设置为 `_start` 函数，该函数通常由标准库提供。
2. **初始化**：`_start` 函数会进行一些基础设置和初始化，例如调用全局和静态对象的构造函数。
3. **调用 `main`**：初始化完成后，`_start` 函数会调用 `main` 函数，并传递命令行参数。
4. **退出处理**：`main` 函数返回后，控制权会回到 `_start` 函数，进行一些清理工作，然后调用系统调用（如 `exit`）终止程序。

**低地址还是高地址**

程序的加载地址（低地址还是高地址）并不是固定的，而是由操作系统和编译器的配置决定的。一般来说，代码段会加载到较低的地址，而栈通常会从高地址向低地址增长。

### 如何判断大端小端

通过检查内存中多字节数据的存储顺序来判断字节序：

1. **设定一个已知值**：例如，`0x00000001`。
2. **查看最低字节**：通过将该值的地址转换为字符指针（或字节数组）来访问最低字节。
3. 判断字节序：
   - 如果最低字节是 `0x01`，则为小端（Little Endian）。
   - 如果最低字节是 `0x00`，则为大端（Big Endian）。